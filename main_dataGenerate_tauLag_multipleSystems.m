%% Description

%{

Generate non-linear auto-regressive model and simulate

General form - y = Ax + Bx' + e
    x' is nonlinearity

Generates multiple runs for multiple systems (with different connections)

%}

%%

addpath('ar_nonlinear/');

%% Simulation parameters

% Time series length to simulate
nSamples = 200000;

% Number of time series to simulate, per system
nRuns = 10;

%% General model parameters
model_type = '3chMotifsNLThresh0_9Lag9-11'; % name of the model

model_params = struct();

% Constants/starting points (nodes x 1)
model_params.constant = [0; 0; 0];

% Nonlinear function name ('NL' = 'nonlinear')
model_params.NL_func = 'thresh';
model_params.NL_params = struct();
model_params.NL_params.thresh = [0.9; 0.9]; % (nodes x 1)
model_params.NL_params.thresh = [0.9; 0.9; 0.9]; % (nodes x 1)

% If value exceeds thresohld, spike to given value
model_params.NL_params.spike = 0;
model_params.NL_params.spikeVals = model_params.NL_params.thresh; % (nodes x 1)

% Reset if thresholds exceeded
model_params.NL_params.reset = 0;
model_params.NL_params.resetVals = -model_params.NL_params.thresh;

% Set time delay for causal interactions
model_params.t_params.delay = [9 10 11]; % timesteps before
model_params.t_params.delay_probs = [25 50 25];

%% Model connectivity parameters
% Self-connectivity constant
% Cross-connectivity varying
% Innovations covariance constant

% 3-node network motifs - Milo et al. 2002 Science Fig 1B
%   Models 1-13 match with motifs 1-13 in Fig 1B
%       Nodes are labelled as A,B,C (top to bottom node in Fig 1B)

% A - Linear connection matrix (nodes x nodes x time-lag)
%   Only linear effects from self, none from others
% B - Nonlinear connection matrix (nodes x nodes x time-lag)
% Covariance - Instantaneous noise covariance (nodes x nodes)
%   To generate noise from covariance:
%       https://au.mathworks.com/matlabcentral/answers/358204-how-to-generate-gaussian-noise-with-certain-covariance-and-zero-mean
%       See also MATLAB function simulate(varm)

models = struct([]);

models(1).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(1).B = [...
    0 0.4 0;...
    0 0 0;...
    0 0.4 0];
models(1).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(2).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(2).B = [...
    0 0.4 0;...
    0 0 0.4;...
    0 0 0];
models(2).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(3).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(3).B = [...
    0 0.4 0;...
    0 0 0.4;...
    0 0.4 0];
models(3).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(4).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(4).B = [...
    0 0.4 0.4;...
    0 0 0;...
    0 0 0];
models(4).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(5).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(5).B = [...
    0 0.4 0.4;...
    0 0 0;...
    0 0.4 0];
models(5).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(6).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(6).B = [...
    0 0.4 0.4;...
    0 0 0.4;...
    0 0.4 0];
models(6).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(7).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(7).B = [...
    0 0 0;...
    0.4 0 0.4;...
    0 0.4 0];
models(7).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(8).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(8).B = [...
    0 0.4 0;...
    0.4 0 0.4;...
    0 0.4 0];
models(8).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(9).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(9).B = [...
    0 0 0.4;...
    0.4 0 0;...
    0 0.4 0];
models(9).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(10).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(10).B = [...
    0 0.4 0.4;...
    0.4 0 0;...
    0 0.4 0];
models(10).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(11).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(11).B = [...
    0 0.4 0.4;...
    0.4 0 0.4;...
    0 0 0];
models(11).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(12).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(12).B = [...
    0 0.4 0.4;...
    0.4 0 0.4;...
    0 0.4 0];
models(12).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

models(13).A = [...
    -0.1 0 0;...
    0 -0.1 0;...
    0 0 -0.1];
models(13).B = [...
    0 0.4 0.4;...
    0.4 0 0.4;...
    0.4 0.4 0];
models(13).Covariance = [...
    0.5 0 0;...
    0 0.5 0;...
    0 0 0.5];

%% Simple check for stability (unreliable?)

% Check for stability (so system doesn't explode)
%   Not sure if check is correct (and what about imaginary eigenvalues?)
%   Check applies to linear systems
% Note for stability/stationarity:
%   https://kevinkotze.github.io/ts-7-var/#fn6 - see section 1.3
%   Lutkepohl, H. 2005. New Introduction to Multiple Time Series Analysis. Heidelberg: Springer-Verlang.

for m = 1 : length(models)
    model = models(m);
    eigs = eig(det(model.A + model.B));
    if any(eigs > 1)
        warning(['model ' num2str(m) ' - VAR probably unstable']);
    end
end

%% Check cross connections

figure;
for m = 1 : length(models)
    subplot_size = ceil(sqrt(length(models)));
    subplot(subplot_size, subplot_size, m);
    imagesc(models(m).B); colorbar;
    axis square
end

%% Plot connectivity graphs

%% Simulate data for each model
% See MATLAB functions simulate(varm) and filter(varm) for reference

model_data = struct([]);

parfor m = 1 : length(models)
    
    model = models(m);
    
    lags = size(model.A, 3); % this is AR order
    
    % Same format as fly_data (samples x channels x trials x flies x conditions)
    data = zeros(nSamples, size(model.A, 1), 1, nRuns, 1);
    data_E = zeros(size(data)); % Contributions from noise
    
    for run = 1 : nRuns
        tic;
        
        % Generate noise (see filter(); using ?lower Cholesky factor)
        noise_independent = randn(size(model.A, 1), nSamples); % (channels x samples), see filter()
        L = chol(model.Covariance, 'lower'); % Lower Cholesky factor
        noise = (L * noise_independent);
        
        % Store noise
        data_E(:, :, 1, run, 1) = noise'; % (samples x channels)
        
        % Prepend (zeros) and add starting conditions
        % Remember, noise is (channels x samples)
        prepend_length = max(lags, max(model_params.t_params.delay));
        Y = cat(2, zeros(size(model.A, 1), prepend_length), noise + model_params.constant);
        
        % Step through time to determine samples in the future
        %   At t, determine sample in the future at t+lag
        for t = 1 : nSamples
            
            % Check if spiking
            if model_params.NL_params.spike == 1
                for node = 1 : size(model.A, 1)
                    if Y(node, t) >= model_params.NL_params.thresh(node)
                        Y(node, t) = model_params.NL_params.spikeVals(node);
                    end
                end
            end
            
            % Determine delays per every pairing of nodes
            if length(model_params.t_params.delay) == 1
                delays = repmat(model_params.t_params.delay, [size(model.A, 1) size(model.A, 1)]);
            else
                delays = randsample(model_params.t_params.delay, size(model.A, 1).^2, true, model_params.t_params.delay_probs);
            end
            delays = reshape(delays, [size(model.A, 1) size(model.A, 1)]);
            
            % Iterate through each AR lag
            for lag = 1 : size(model.A, 3)
                
                % Node delays are independent
                for node = 1 : size(model.A, 1) % for each source nocde
                    for link = 1 : size(delays, 2)
                        nl = feval(model_params.NL_func, Y(node, t), model_params.NL_params);
                        % Add current sample to noise in the future
                        Y(link, t+delays(link, node)) = Y(link, t+delays(link, node)) +...
                            model.A(link, node, lag) * Y(node, t) +...
                            model.B(link, node, lag) .* nl(node);
                    end
                end
                
            end
            
        end
        
        % Check if spiking, for remaining t
        for t = nSamples+1 : size(Y, 2)
            if model_params.NL_params.spike == 1
                for node = 1 : size(model.A, 1)
                    if Y(node, t) >= model_params.NL_params.thresh(node)
                        Y(node, t) = model_params.NL_params.spikeVals(node);
                    end
                end
            end
        end
        
        % Store simulated data
        data(:, :, 1, run, 1) = Y(:, prepend_length+1:end)'; % (samples x channels); excluded prepended points
        
        toc
    end
    
    model_data(m).data = data;
    model_data(m).data_E = data_E;
    
end

%% Save

out_dir = 'sim_data/';
out_file = [model_type '_nSamples' num2str(nSamples) '_nRuns' num2str(nRuns)];

save([out_dir out_file], 'model_type', 'models', 'model_params', 'nSamples', 'model_data', '-v7.3', '-nocompression');

disp(['saved: ' out_file]);
